import { PipelineStep, PipelineContext } from '../index';
import { Knex } from 'knex';

/*
    Conciliation step between Base A (contábil) and Base B (fiscal).
    Responsibilities:
    - load configuration and bases
    - ensure result table exists with key columns
    - collect marks and match/unmatch groups by configured keys
    - insert result rows in batches
*/

const RESULT_INSERT_CHUNK = 200;
const EPSILON = 1e-6;

const STATUS_CONCILIADO = '01_Conciliado';
const STATUS_FOUND_DIFF = '02_Encontrado c/Diferença';
const STATUS_NOT_FOUND = '03_Não Encontrado';

const LABEL_CONCILIADO = 'Conciliado';
const LABEL_DIFF_IMATERIAL = 'Diferença Imaterial';
const LABEL_NOT_FOUND = 'Não encontrado';

type ConfigConciliacaoRow = {
    id: number;
    base_contabil_id: number;
    base_fiscal_id: number;
    chaves_contabil?: string | null;
    chaves_fiscal?: string | null;
    coluna_conciliacao_contabil?: string | null;
    coluna_conciliacao_fiscal?: string | null;
    inverter_sinal_fiscal?: number | boolean | null;
    limite_diferenca_imaterial?: number | null;
};

type BaseRow = { id: number; tabela_sqlite?: string | null };

type MarkRow = { id: number; base_id: number; row_id: number; status?: string | null; grupo?: string | null; chave?: string | null };

type ResultEntry = Record<string, any>;

export class ConciliacaoABStep implements PipelineStep {
    name = 'ConciliacaoAB';

    constructor(private readonly db: Knex) {}

    private async ensureResultTable(jobId: number) {
        const tableName = `conciliacao_result_${jobId}`;
        const exists = await this.db.schema.hasTable(tableName);
        if (!exists) {
            await this.db.schema.createTable(tableName, table => {
                table.increments('id').primary();
                table.integer('job_id').notNullable();
                table.string('chave').nullable();
                table.string('status').nullable();
                table.string('grupo').nullable();
                table.integer('a_row_id').nullable();
                table.integer('b_row_id').nullable();
                table.text('a_values').nullable();
                table.text('b_values').nullable();
                table.float('value_a').nullable();
                table.float('value_b').nullable();
                table.float('difference').nullable();
                table.timestamp('created_at').defaultTo(this.db.fn.now()).notNullable();
            });
        }
        return tableName;
    }

    private parseChaves(raw?: string | null): Record<string, string[]> {
        if (!raw) return {};
        try {
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) return { CHAVE_1: parsed };
            if (parsed && typeof parsed === 'object') return parsed as Record<string, string[]>;
        } catch (_) {
            // ignore parse errors and return empty
        }
        return {};
    }

    private buildComposite(row: any, cols?: string[] | undefined | null): string | null {
        if (!row || !cols || cols.length === 0) return null;
        return cols.map(c => String(row[c] ?? '')).join('_');
    }

    private normalizeAmount(value: number) {
        if (value === 0) return 0;
        return Number(Number(value).toFixed(6));
    }

    private async getRowFromTable(table: string, id: number, cache: Map<number, any>) {
        if (cache.has(id)) return cache.get(id);
        const row = await this.db.select('*').from(table).where({ id }).first();
        if (row) cache.set(id, row);
        return row ?? null;
    }

    private async ensureResultColumns(tableName: string, keys: string[]) {
        if (!keys || keys.length === 0) return;
        const exists = await this.db.schema.hasTable(tableName);
        if (!exists) return;
        for (const k of keys) {
            const has = await this.db.schema.hasColumn(tableName, k);
            if (!has) {
                await this.db.schema.alterTable(tableName, t => {
                    t.text(k).nullable();
                });
            }
        }
    }

    private async loadMarksForBases(baseAId: number, baseBId: number) {
        const rows = await this.db<MarkRow>('conciliacao_marks').whereIn('base_id', [baseAId, baseBId]).select('*');
        const marksA = new Map<number, MarkRow>();
        const marksB = new Map<number, MarkRow>();
        for (const m of rows) {
            if (m.base_id === baseAId && !marksA.has(m.row_id)) marksA.set(m.row_id, m);
            if (m.base_id === baseBId && !marksB.has(m.row_id)) marksB.set(m.row_id, m);
        }
        return { marksA, marksB } as { marksA: Map<number, MarkRow>; marksB: Map<number, MarkRow> };
    }

    private async findMatchedPairsForKey(tableA: string, tableB: string, aCols: string[], bCols: string[]) {
        const aAlias = 'a';
        const bAlias = 'b';
        const query = this.db
            .select(this.db.raw(`${aAlias}.id as a_row_id`), this.db.raw(`${bAlias}.id as b_row_id`))
            .from({ [aAlias]: tableA })
            .innerJoin({ [bAlias]: tableB }, function () {
                const maxLen = Math.max(aCols.length || 0, bCols.length || 0);
                for (let i = 0; i < maxLen; i++) {
                    const aKey = aCols[i] || aCols[0];
                    const bKey = bCols[i] || bCols[0];
                    if (aKey && bKey) this.on(`${aAlias}.${aKey}`, '=', `${bAlias}.${bKey}`);
                }
            });
        return query;
    }

    async execute(ctx: PipelineContext): Promise<void> {
        const cfgId = ctx.configConciliacaoId;
        if (!cfgId) return;

        const cfg = await this.db<ConfigConciliacaoRow>('configs_conciliacao').where({ id: cfgId }).first();
        if (!cfg) return;

        const baseAId = ctx.baseContabilId ?? cfg.base_contabil_id;
        const baseBId = ctx.baseFiscalId ?? cfg.base_fiscal_id;
        if (!baseAId || !baseBId) return;

        const baseA = await this.db<BaseRow>('bases').where({ id: baseAId }).first();
        const baseB = await this.db<BaseRow>('bases').where({ id: baseBId }).first();
        if (!baseA || !baseA.tabela_sqlite || !baseB || !baseB.tabela_sqlite) return;

        const tableA = baseA.tabela_sqlite as string;
        const tableB = baseB.tabela_sqlite as string;

        const chavesContabil = this.parseChaves(cfg.chaves_contabil);
        const chavesFiscal = this.parseChaves(cfg.chaves_fiscal);

        const keyIdentifiers = Array.from(new Set([...Object.keys(chavesContabil), ...Object.keys(chavesFiscal)]));

        const colA = cfg.coluna_conciliacao_contabil ?? undefined;
        const colB = cfg.coluna_conciliacao_fiscal ?? undefined;
        const inverter = !!cfg.inverter_sinal_fiscal;
        const limite = Number(cfg.limite_diferenca_imaterial || 0);

        const jobId = ctx.jobId;
        const resultTable = await this.ensureResultTable(jobId);
        await this.ensureResultColumns(resultTable, keyIdentifiers);

        const aRowCache = new Map<number, any>();
        const bRowCache = new Map<number, any>();

        const { marksA, marksB } = await this.loadMarksForBases(baseAId, baseBId);

        const inserts: ResultEntry[] = [];
        const matchedA = new Set<number>();
        const matchedB = new Set<number>();

        // Process pre-existing marks (A and B) first
        for (const [rowId, mark] of marksA.entries()) {
            const aRow = await this.getRowFromTable(tableA, rowId, aRowCache);
            if (!aRow) continue;
            const markKey = mark?.grupo ?? mark?.chave ?? null;
            const valueA = aRow && colA ? Number(aRow[colA]) || 0 : 0;
            const diff = valueA - 0;

Everything looks consistent. Good. Next: update todo list. Use manage_todo_list write to mark id1 and id2 completed. Provide preamble: 